# Recitation Presentations

## Premise
<note>
<p>Every couple of weeks or so we will transition between overarching topics in lecture. We will also cover some specific use cases, structures, and or algorithms. However, as 
theres only so much time and a world of algorithms, We're going to have a little fun exploring what's out there. Labs beyond Week 4 this term, will consist of weekly presentations on known algorithms under the blanket of the current overarching lecture topic. There are four overarching topics for the term: Sorting, Trees, Graphs, Hash Tables.</p>
</note>

## Recitation Breakout

Labs attendees will be broken out into two groups, presenters and evaluators.

### Presenters

Presenters will have five (5) minutes to get set up and ten (10) minutes to present their topic. Presenters will be expected to have a whiteboard presentation 
prepared showing off the pseudo-concepts of the structure or algorithm selected. You may choose how the work is divided amongst your group. However, it must be clearly 
documented what/how each member contributed for the group to receive any credit for the presentation.

### Evaluators

Evaluators will take the proceeding five (5) minutes after each presentation to complete a survey about the presentation you just viewed. Your task is to respond to 
the questions honestly and complete the survey questions through Gradescope, by end of day. The final question in the survey will be a short answer question. This will require 
you to have been paying attention to the presentation as you will be asked provide a question you would like to know more about this topic.

## Requirements

<procedure style="choices">
<p>Presentations must cover the following subtopics:</p>
<step>Definition &amp; Historical Context</step>
<step>Properties &amp; Basic Operations**</step>
<step>Time &amp; Space Complexity</step>
</procedure>

<note>** Basic operations must be relayed in a whiteboard presentation. It can be through flow-charting, pseudocode, and or structural drawings.</note>

## Grading

Each of you will present four (4) times this term. Each presentation will be worth 25 points.

<procedure style="choices">
<p>Sorting Algorithm Day 1</p>
<step>Bubble Sort</step>
<step>Heap Sort</step>
<step>Radix Sort</step>
<step>Counting Sort</step>
<step>Bucket Sort</step>
</procedure>

<procedure style="choices">
<p>Sorting Algorithm Day 2</p>
<step>Shell Sort</step>
<step>Comb Sort</step>
<step>Tim Sort</step>
<step>Tree Sort</step>
<step>Cycle Sort</step>
</procedure>

<procedure style="choices">
<p>Mathematically-sounding Tree Day</p>
<step>Fenwick Tree</step>
<step>Cartesian Tree</step>
<step>Interval Tree</step>
<step>Range Tree</step>
<step>Radix Tree</step>
<step>Min-Max Tree</step>
</procedure>

<procedure style="choices">
<p>Alphabet Tree Day</p>
<step>B-Tree</step>
<step>H-Tree</step>
<step>H-BTree</step>
<step>K-D Tree</step>
<step>R-Tree</step>
<step>T-Tree</step>
<step>X-Tree</step>
<step>Y-Tree</step>
<step>SP-Tree</step>
<step>UB-Tree</step>
</procedure>

<procedure style="choices">
<p>Alphabet Tree Day</p>
<step>Trie</step>
<step>Suffix Tree</step>
<step>Segment Tree</step>
<step>Quadtree</step>
<step>Octree</step>
<step>Splay Tree</step>
<step>Treep</step>
</procedure>

<procedure style="choices">
<p>Hash Bucket Day</p>
<step>Hash Bucket Skip List</step>
<step>Hash Bucket Cuckoo Hashing</step>
<step>Hash Bucket Hopscotch Hashing</step>
<step>Hash Bucket Robin Hood Hashing</step>
<step>Hash Bucket Coalesced Hashing</step>
<step>Hash Bucket Extendible Hashing</step>
<step>Hash Bucket Perfect Hashing</step>
<step>Hash Bucket Minimal Perfect Hashing</step>
<step>Hash Bucket Bloom Filter</step>
<step>Hash Bucket Counting Bloom Filter</step>
<step>Hash Bucket Scalable Bloom Filter</step>
</procedure>

<procedure style="choices">
<p>Greedy Algorithms Day</p>
<step>Dijkstra's Algorithm</step>
<step>Prim's Algorithm</step>
<step>Kruskal's Algorithm</step>
<step>Fractional Knapsack</step>
<step>Huffman Coding</step>
</procedure>


[//]: # (During select labs for the term we will take a step back and work on presentations. Presentations will consist of small glimpses into the world of data structures and algorithms. These will be structures not covered in the lecture but are part of an overarching theme for the week. )

[//]: # ()
[//]: # (<table style="none">)

[//]: # (<tr>)

[//]: # (<td>)

[//]: # (<procedure style="choices">)

[//]: # (<b>Collections</b>)

[//]: # (<step>Set</step>)

[//]: # (<step>Map</step>)

[//]: # ()
[//]: # (<step>Deque</step>)

[//]: # (<step>Bag</step>)

[//]: # (<step>Multiset</step>)

[//]: # (<step>Multimap</step>)

[//]: # (<step>Multistack</step>)

[//]: # (<step>Multiqueue</step>)

[//]: # (<step>Multibag</step>)

[//]: # (<step>Multideque</step>)

[//]: # (<step>Multimap</step>)

[//]: # (</procedure>)

[//]: # (</td>)

[//]: # (<td>)

[//]: # (<procedure style="choices">)

[//]: # (<b>Tree</b>)

[//]: # (<step>Binary Tree</step>)

[//]: # (<step>Binary Search Tree</step>)

[//]: # (<step>AVL Tree</step>)

[//]: # (<step>Red-Black Tree</step>)

[//]: # (<step>B-Tree</step>)

[//]: # (<step>Trie</step>)

[//]: # (<step>Suffix Tree</step>)

[//]: # (<step>Segment Tree</step>)

[//]: # (<step>K-D Tree</step>)

[//]: # (<step>Quadtree</step>)

[//]: # (<step>Octree</step>)

[//]: # (<step>Splay Tree</step>)

[//]: # (<step>Treap</step>)

[//]: # (<step>Scapegoat Tree</step>)

[//]: # (<step>Fenwick Tree</step>)

[//]: # (<step>Cartesian Tree</step>)

[//]: # (<step>Interval Tree</step>)

[//]: # (<step>Range Tree</step>)

[//]: # (<step>Radix Tree</step>)

[//]: # (<step>T-Tree</step>)

[//]: # (<step>R-Tree</step>)

[//]: # (<step>X-Tree</step>)

[//]: # (<step>Y-Tree</step>)

[//]: # (<step>SP-Tree</step>)

[//]: # (<step>UB-Tree</step>)

[//]: # (<step>Min-Max Tree</step>)

[//]: # (<step>H-Tree</step>)

[//]: # (<step>H-BTree</step>)

[//]: # (</procedure>)

[//]: # (</td>)

[//]: # (</tr>)

[//]: # (<tr>)

[//]: # (<td>)

[//]: # (<procedure style="choices">)

[//]: # (<b>Hash Table</b>)

[//]: # ()
[//]: # (</procedure>)

[//]: # (</td>)

[//]: # (<td>)

[//]: # (<procedure style="choices">)

[//]: # (<b>Graph</b>)

[//]: # ()
[//]: # (</procedure>)

[//]: # (</td>)

[//]: # (</tr>)

[//]: # (</table>)

[//]: # ()
[//]: # ()
[//]: # ()
[//]: # ()
[//]: # ()
[//]: # (## Graph)

[//]: # ()
[//]: # ()
[//]: # (- Directed Acyclic Graph)

[//]: # (- Directed Cyclic Graph)

[//]: # (- Undirected Acyclic Graph)

[//]: # (- Undirected Cyclic Graph)

[//]: # (- Bipartite Graph)

[//]: # (- Complete Graph)

[//]: # (- Connected Graph)

[//]: # (- Disconnected Graph)

[//]: # (- Strongly Connected Graph)

[//]: # (- Weakly Connected Graph)

[//]: # (- Sparse Graph)

[//]: # (- Dense Graph)

[//]: # (- Incidence Matrix)

[//]: # (- Incidence List)

[//]: # (- Edge List)

[//]: # (- Adjacency Multilist)

[//]: # (- Adjacency Set)

[//]: # (- Adjacency Array)

[//]: # ()
[//]: # (## Hash Table)

[//]: # ()
[//]: # (- Hash Table)

[//]: # (- Hash Function)

[//]: # (- Hash Collision)

[//]: # (- Hash Buckets)

[//]: # (- Hash Bucket)

[//]: # (- Hash Bucket Array)

[//]: # (- Hash Bucket Linked List)

[//]: # (- Hash Bucket Binary Search Tree)

[//]: # (- Hash Bucket Red-Black Tree)

[//]: # (- Hash Bucket AVL Tree)

[//]: # (- Hash Bucket Splay Tree)

[//]: # (- Hash Bucket Treap)

[//]: # (- Hash Bucket Skip List)

[//]: # (- Hash Bucket Cuckoo Hashing)

[//]: # (- Hash Bucket Hopscotch Hashing)

[//]: # (- Hash Bucket Robin Hood Hashing)

[//]: # (- Hash Bucket Linear Probing)

[//]: # (- Hash Bucket Quadratic Probing)

[//]: # (- Hash Bucket Double Hashing)

[//]: # (- Hash Bucket Coalesced Hashing)

[//]: # (- Hash Bucket Dynamic Hashing)

[//]: # (- Hash Bucket Extendible Hashing)

[//]: # (- Hash Bucket Fibonacci Hashing)

[//]: # (- Hash Bucket Perfect Hashing)

[//]: # (- Hash Bucket Minimal Perfect Hashing)

[//]: # (- Hash Bucket Bloom Filter)

[//]: # (- Hash Bucket Counting Bloom Filter)

[//]: # (- Hash Bucket Scalable Bloom Filter)

[//]: # ()
[//]: # (## Greedy Algorithms)

[//]: # ()
[//]: # (Dijkstra's Algorithm:)

[//]: # (Definition: Dijkstra's algorithm is used to find the shortest path between nodes in a weighted graph. It starts at a given node and selects the edge with the smallest total weight at each step, updating the distance to each neighboring node.)

[//]: # (Prim's Algorithm:)

[//]: # (Definition: Prim's algorithm is employed to find a minimum spanning tree for a weighted, connected graph. It starts with an arbitrary node and repeatedly adds the edge with the smallest weight that connects a vertex in the tree to a vertex outside the tree.)

[//]: # (Kruskal's Algorithm:)

[//]: # (Definition: Kruskal's algorithm also finds a minimum spanning tree for a graph, but it works by sorting the edges by weight and then adding them to the spanning tree one at a time, avoiding cycles.)

[//]: # (Fractional Knapsack:)

[//]: # (Definition: In the fractional knapsack problem, items with weights and values are given, and the goal is to maximize the total value of items in the knapsack without exceeding its weight capacity. The algorithm selects items based on their value-to-weight ratio.)

[//]: # (Huffman Coding:)

[//]: # (Definition: Huffman coding is a technique used for lossless data compression. It constructs a variable-length prefix coding tree in which frequently occurring characters have shorter codes, optimizing the overall compression.)

[//]: # (Interval Scheduling:)

[//]: # (Definition: In the interval scheduling problem, a set of tasks with start and end times is given, and the goal is to find the maximum number of non-overlapping tasks. The greedy strategy involves sorting tasks by their end times and selecting the earliest finishing tasks.)

[//]: # (Activity Selection:)

[//]: # (Definition: Similar to interval scheduling, activity selection involves choosing the maximum number of non-overlapping activities from a set of activities, each with a start and finish time. The algorithm selects activities based on their finish times.)